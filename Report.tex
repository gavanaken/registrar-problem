\documentclass[11pt, oneside]{article}   	% use "amsart" instead of "article" for AMSLaTeX format
\usepackage{geometry}
\usepackage[]{algorithm2e}
\geometry{letterpaper}
\usepackage{graphicx}
\usepackage{amssymb}
\usepackage{amsthm}
\usepackage{parskip}

\graphicspath{ {images/} }

\newtheorem*{theorem}{Theorem}
\newtheorem*{lemma}{Lemma}
%SetFonts

\title{CS340 - Registrar Project}
\author{Greg Van Aken, Conor Stuart Roe, Russell Gerhard}
%\date{}							% Activate to display a given date or no date

\begin{document}
\maketitle

\section{Checkpoint 2}
\subsection{Description}
This algorithm works by assigning conflict scores to each pair of classes based on teacher assignments and student preferences and assigning each class to be the sole member of a set, then continuously merging sets of classes (designating them to occupy the same time slot) in a greedy manner, on the basis of lowest total set conflict scores. \\

Call the number of classes as $n$. Initialize a "conflict matrix" $M$, an $n \times n$ 2-D matrix for storing conflict scores, setting all values to 0. Additionally, create a union-find object $S$ and assign each class to its own set within $S$. For each teacher, each pair of classes they teach ($c$, $c^\prime$) definitely cannot occupy the same time slot, so the conflict score $M[c][c^\prime]$ is set to {\it Infinity} (or some sufficiently large number). Then each student's preference list is iterated through, and for each class pair $(c, c^\prime)$ in a given student's preference list, compute the conflict score ((4-index($c$)) + (4-index($c^\prime$))) for that pair (for example, if $c$ is in position 0 (top choice) and $c^\prime$ is in position 1 (next choice), the student prefers both of those classes highly and their overlap will be a cost of 7) and increment $M[c_i][c_j]$  by that conflict score. To ensure that we only need to use the upper triangle of the matrix, we will adopt the convention of always indexing such that $i < j$. \\

Create a priority queue $P$ with a min heap to keep track of the pair of sets with lowest conflict score, and add each cell not along the diagonal to $P$. Sets are identified with unique group ID numbers, and as new sets are created by merging, they are given incrementally larger group ID numbers. While the number of sets in $S$ is greater than the number of class times, classes still haven't been grouped into sufficiently few time slots, so merging must continue. \\

 At each step, find the sets $s_i$, $s_j$ with the minimum conflict score by popping from $P$. It is a common occurrence that one or both sets specified by $s_i$ and $s_j$ no longer "exist" - that is, the sets they represent have already been merged with some other set, in which case the pair is disregarded. Otherwise, an attempt is made to merge the sets. If $|s_i| + |s_j|$ is less than the number of classrooms, the sets can be merged without creating too large a time slot, so the sets are merged, otherwise that pair is also simply disregarded. When a merge takes place between $s_i$ and $s_j$ to form set $s_k$, the conflict score of any other set $s_o$ with $s_k$ should be the sum of $s_o$'s conflict scores with $s_i$ and $s_j$, since it now conflicts with all the classes in both, so row and column $j$ are added to row and column $i$, and $i$ is designated as the representative row/column of group $s_k$. Row/column $j$ continue to exist to avoid matrix resizing, but they are never again looked at. The $i^{th}$ row and column now represent the set $s_k$, which contains all the classes originally in either set $s_i$ or $s_j$. Join the two sets in $S$ as well.

Each iteration reduces the number of sets in $S$ by one. Once the number of sets in $S$ is equal the number of time slots, each class set can be arbitrarily assigned to a time slot.

Finally, we initialize a dictionary, S, whose keys are course numbers and values are dictionaries containing room, time, teacher, and student list for each course. We fill out this dictionary from the constraints such that:
\begin{enumerate}
    \item Each class group has a time, so every class in that group gets that time slot.
    \item The larger classes in a given class group get the larger rooms (this requires some sorting).
    \item The number of students in a class does not exceed the capacity of the assigned room (a simple check at the end of schedule creation).
\end{enumerate}

Teacher conflicts cannot arise in schedule creation because the handling of teacher conflicts is baked into the groups created from the conflict matrix. In this way, we create a valid schedule from our class groups.

\subsection{Pseudocode}
\begin{algorithm}
\SetKwFunction{Main}{Main}
\SetKwProg{Fn}{Function}{}{}
\Fn{\Main{Preferences, numClasses, Teachers}}{
let $n$ = len(numClasses);
initialize $M$ = n x n 2-D array of all 0's;

$M$ = setTeach($M$, $Teachers$);

$M$ = setCost($M$, $Preferences$);

createSets(M);


}
\end{algorithm}

\begin{algorithm}
\SetKwFunction{setTeach}{setTeach}
\SetKwProg{Fn}{Function}{}{}
\Fn{\setTeach{M, Teachers}}{
sort $Teachers$ by teacher id // Teachers is a list of class-teacher pairs \\
initialize $prev$ = Teachers[0] \\
\While{$i=1 < len(Teachers)$} {
let $teach$ = Teachers[i] \\
\If{teach[1] == prev[1]} {
set $M$[teach[0]][prev[0]] to $infinity$ // teacher teaches both classes \\
}
set $prev$ = Teachers[i] \\
i++ \\
}
\Return{$M$}
}
\end{algorithm}

\begin{algorithm}[H]
\SetKwFunction{setCost}{setCost}
\SetKwProg{Fn}{Function}{}{}
\Fn{\setCost{M, Preferences}}{
\For{student in Preferences} {
// Assume Preferences = [[p1,p2,p3,p4],[p1,p2,p3,p4],...]

\For{i in range(0:4)} {
{
\For{j in range(i+1:4)} {
let $c1$ = student[i]; let $c2$ = student[j];

$M$[$c1$][$c2$] += ((4-i) + (4-j))
}
}
}
}
}
\end{algorithm}

\begin{algorithm}[H]
\SetKwFunction{createSets}{createSets}
\SetKwProg{Fn}{Function}{}{}
\Fn{\createSets{M}}{
    \# M is an $n$ by $n$ matrix \\
    Initialize a union-find object, $S$ \\
    \For{each class}{
         Initialize a disjoint set of size one containing that class, stored in $S$ \\
    }
    Initialize a priority queue $P$ with all values from M in it \\
    \While{number of sets in $S$ $\geq$ the number of time slots}{
        Pop $(S_i, S_j)$ \\
        \If {either $S_i$ or $S_j$ has already been merged} {pass}
        \ElseIf{$|S_i|+|S_j| \leq$ the number of classrooms}{
            merge $S_k = S_i \cup S_j$ \\
            Add row and column $j$ to row and column $i$ \\
            Designate row and column $i$ as the location of $S_k$'s conflict scores \\
            Push all of $S_k$'s conflict scores to $P$ \\
        }
    }
    \For{each disjoint set $s$ in $S$}{
        assign $s$ to an unassigned time slot \\
        \For {each class $c$ in $s$}{
            assign $c$ to an unassigned classroom
        }
    }
\# write output to a file
}
\end{algorithm}

\begin{algorithm}
\SetKwFunction{createSchedule}{createSchedule}
\SetKwProg{Fn}{Function}{}{}
\Fn{\createSchedule{}}{
    initialize an empty dictionary, S \\
    roomSorted = sorted rooms by room size \\
    \For{each course}{
        S[course] = a dictionary containing 4 key-value pairs for room, teacher, time, and student list \\
    }
    \For{each course}{
        S[course][teacher] = teacher of that course, as given by constraints \\
    }
    \For{each preference list P}{
        \For{each course in P}{
            S[course][student list] = append the student whose preference list we are examining \\
        }
    }
    \# This next variable is used to compute groupSorted below \\
    classSorted = sorted courses by how many students want to take them \\
    \For{group,i in enumerate(classGroups)}{
        groupSorted = sort courses in group by how many students want to take them \\
        \For{each course,j in enumerate(groupSorted}{
            S[course][time] = i \\
            S[course][room] = $j^{th}$ element of roomSorted \\
        }
    }
    create a dictionary, R, from room constraint, where rooms are keys and room sizes are values \\
    \For{each course}{
        check that the size of it's students list is not greater than the room size of the room to which it's assigned \\
        If there are too many students, remove as many as needed until they fit into the given room size \\
    return S \\
    }
    }
\end{algorithm}

\# We have omitted the function that writes the output file, as it is merely an implementation detail once the schedule object has been created by \textit{createSchedule}. \\

\newpage
\subsection{Time Analysis}

Call the number of teachers $t$, the number of students $s$, and the number of classes $n$. \\

 setTeach contains a sort of teachers, which takes $O(t$log$t)$ time. Then it iterates over teachers performing constant time operations, so taking $O(t)$ time. Overall, setTeach is $O(t$log$t)$. \\

 setCost contains a triply nested loop, but the number of loops of the two inner loops is fixed rather than related to any input. Specifically, six innermost loops occur per student. Thus the total time is $O(s)$. \\

 createSets is a more complex function. The way it is written, initialization of the Union-Find, which contains one set per class, is $O(n)$. Initializing the priority queue is constant, but pushing all $O(n^2)$ values of $M$ to it is $O(n^2$log$(n^2)) = O(n^2$log$n)$. All sets must be merged by the time the priority queue is empty, so the maximum number of iterations of the \textbf{while} is no more than the maximum number of entries ever created in the priority queue $P$. Since every group merge reduces the number of class groups by 1, at most $n-1$ merges may take place, so at most $2n-1$ groups can ever be created before all classes are in one group. Each conflict score is between two groups, so the total number of possible conflicts to store in $P$ is $O((2n-1)^2) = O(n^2)$. The time of popping from $P$ is $O($log$(n^2)) = O($log$n)$. Checking whether a group has already been merged, checking the group sizes of $S_i$ and $S_j$, and merging sets are all constant time with our data structures. Adding rows and pushing them to $P$ can occur in total as many times as there are possible conflict scores, again $O(n^2)$, so it does not actually increase the time complexity of the \textbf{while}. Overall the most complex operations that occurs for every loop are the pop and push to $P$, which are $O($log$n)$, so the total complexity of the \textbf{while} is $O(n^2$log$n)$. Lastly, the double \textbf{for} iterates over all classes, performing a constant time operation of assignment, so its complexity is $O(n)$. The dominating complexity of createSets is $O(n^2$log$n)$. \\

 Each function is performed once during the algorithm's run, so the time complexity is their sum $O(t+s+n^2$log$n)$. Assuming that the number of classes taught by each teacher closely hews to an average, the number of teachers is linear relative to the number of classes - under this assumption, the algorithm thus far is $O(s + n^2$log$n)$.
 
 Finally, we have createSchedule. The initialization of S is O(1). Sorting the list of rooms is O(log(r)), where r is the number of rooms. The dictionary is implemented as a hash table, which will be unfortunate for this section of analysis, as – technically – worst case, insertion and search are O(k), where k is input size. Hence, it is worth noting that the dictionary was selected for its amazing O(1) \textit{average-case} complexity. Additionally, we note that the 'inner' dictionary contains only four key-value pairs, so insertion and search are constant. Continuing the analysis, the first for loop runs $n$ times and makes an insertion in each iteration, however, for \textbf{this} for loop, assignments are unlikely to generate hashing conflicts (as we are filling out the dictionary), so we do not consider them to be O(n), but rather, O(1). Thus, the first for loop is O(n). The second for loop runs $n$ times and makes an insertion at each iteration, so it is O($n^2$). The third and fourth for loops are nested, but the fourth for loop only runs the size of the student preference lists, which is constant. The third for loop runs $s$ times, and an insertion is made during each iteration. Thus, the third and fourth for loops run in O($sn$) time. The fifth and sixth for loops are nested, but the fifth iterates over a constant number of class times, so we only consider the sixth for loop for time complexity analysis. It runs $n$ times, making two insertions, so it runs in O($n^2$) time. The seventh for loop iterates over all courses, running $n$ times, doing a lookup at each iteration and removing at most $n-1$ students if there are too many students for a given room size. So the seventh for loop runs in O($n*(n+n-1)$) $\in$ O($n^2$) time. Since we don't know whether $s$ is bigger than $n$, we cannot be sure which term dominates, and thus, createSets runs in O($sn+n^2$) time. \\
 
 Hence, the algorithm runs in $O(sn + n^2$log$n)$. \\

\subsection{Discussion}

We had a relatively good intuition when approaching this problem that we had to somehow compute a cost associated with having classes at the same time. One option we considered was to weight the cost according to how many students preferred a given class. In other words, for every student that lists some class as their first choice, add a cost of 4 to that class. For every student who lists it as their second choice, add a cost of 3, etc. We realized that although this would determine a set of highly preferred classes that may have a number of students wanting to take them (and thus should not overlap), it loses the logic about what each student wants. A counter example to our initial approach is that there are two popular courses but they occur in different majors. There may be a lot of students who prefer those classes, but few students will desire to take both courses. Thus, it would be reasonable for those classes to overlap. This led us to our current algorithm which makes decisions based on the cost to each student of having two classes overlap. The aspects of this problem which made it difficult to determine an algorithm are:
\begin{enumerate}
\item{How do we quantify the cost of two classes overlapping?}
\begin{itemize}
\item{We decided to set it up such that merging courses is a direct function of their collective priorities}
\item{An artifact of this is that merging classes 1 and 4 has the same cost as merging classes 2 and 3}
\end{itemize}
\item{After a minimum cost is found and then a merge takes place, the cost of merging any third class with the new set will have to include the total merge cost of the third class with every class already in the set} 
\begin{itemize}
\item{This fact led us to the idea of merging matrix rows/columns to reflect the additive costs when sets are merged}
\end{itemize}
\item{A given teacher cannot teach more than one class at a given time}
\begin{itemize}
\item{This issue led us to perform the initialization step of setting matrix cells coorresponding to classes taught by the same teacher to Infinity}
\end{itemize}
\item{A given time slot cannot have more classes scheduled than the given number of rooms}
\begin{itemize}
\item{Because of this, we decided to check to see if this condition is broken and if so, skip that merge}
\end{itemize}
\end{enumerate}
This algorithm is {\bf greedy} because each time work is done, it generally follows a simple rule: merge sets with the lowest merge cost (if a merge is valid). This algorithm is not too different from constructing a minimum spanning tree using Kruskal's algorithm. Classes can be thought of as nodes in a graph and merge cost can be thought of as the weight of the edge between nodes. Similar to a minimum spanning tree, minimum edge weights are selected as the sets are constructed (merged). 

\subsection{Implementation}
We chose to implement this algorithm in Python. Much of the implementation followed directly from our design and pseudocode. We were able to utilize the {\it unionfind} package hosted on {\it https://pypi.org} (licensed to The Python Software Foundation). We needed to modify the implementation slightly to allow for sets to contain more information (class IDs). We also implemented our own min heap to serve as the priority queue. There was one key addition to the algorithm we noticed when attempting to implement. When a set is popped from the priority queue, it's possible that it has already been {\it unioned} with a previously popped set (which would have then been pushed back onto the queue). Thus, we keep track of what has been {\it unioned} and if we pop a set that has been {\it unioned} already, we throw it away and continue with the next set on the queue. This change has been added to our description and pseudocode.

We chose to implement the final schedule as a nested dictionary: each course number is a key that corresponds to a dictionary value; this 'inner' dictionary contains keys whose corresponding values are the teacher, time, room, and student list for the course. We chose this implementation because the schedule information will be accessed often (by students, teachers, and the registrar alike) once it is computed, and the hash table behind Python's built-in dictionary allows for average-case O(1) lookup. \\

\subsection{Experimental Analysis (WIP)}
The algorithm was tested using a number of different random test cases where the number of classes, students, times, and rooms were varried. These results are summarized in Table *********. In many cases the algorithm quickly produced a schedule (in less than 1 second), except in the case of experiment 4 which had a large input of 500 classes and 10,000 students. Furthermore, many of the resultant schedules were relatively optimal, with greater than 80\% of students ultimately enrolled in their preferred classes. 

We also tested the algorithm's performance on the data from Haverford (experiment number 5).

\newpage
\begin{table}[]
\centering
\begin{tabular}{lllllllll}
no. & Classes & Students & Times & Rooms & Time (sec) & Best  & Experimental & \% Optimality \\
1             & 20         & 100         & 5        & 5        & 0.013000011    & 400   & 332          & 0.83          \\
2             & 100        & 2000        & 10       & 20       & 0.36500001     & 8000  & 7066         & 0.88325       \\
3             & 100        & 1000        & 10       & 20       & 0.377999783    & 4000  & 3562         & 0.8905        \\
4             & 500        & 10000       & 60       & 50       & 6.296999931    & 40000 & 39100        & 0.9775        \\
5            & 365            & 1177            & 60       & 50      & 2.94600010         & 4427      & 3718             & 0.83985    \\
              &            &             &          &          &                &       &              &               \\
              &            &             &          &          &                &       &              &               \\
              &            &             &          &          &                &       &              &               \\
              &            &             &          &          &                &       &              &               \\
              &            &             &          &          &                &       &              &               \\
              &            &             &          &          &                &       &              &               \\
              &            &             &          &          &                &       &              &               \\
              &            &             &          &          &                &       &              &              
\end{tabular}
\caption{Results of testing the algorithm with various input parameters}
\label{my-label}
\end{table}

One idea we have that we think will drastically cut down the complexity of our algorithm depends on information from the full enrollment data. There are courses offered by the same department that will likely not have any overlapping interest by students. An example of this might be a 100-level (intro) course and a 300-level course along the same subject track. There is likely no reason for a student to be taking an intro course at the same time as an upper-level course in the same subject. An analysis of enrollment data should help us elucidate whether there are cases of students taking multiple courses of differing levels in the same department and if so what those cases are an how many of them occur. After that analysis, we should be able to initially union courses that would likely never have concurrent interest from any one student. This will cut down on the $O(n^2)$ components of our algorithm because we won't need to look at every single pair.

After analyzing the Haverford Data further, we found that in 2014, there were 44 cases of a student concurrently enrolling in a 100-level and 300-level course in the same subject. We also found that these 44 cases were confined to only 13 departments. In many cases, there were a few (1-3) instances for a given department, but some (Political Science, Music, and Psychology) had a higher number of occurences (5-9), as shown in Table ******.

Another similar circumstance to analyze is whether or not certain departments have very little upper-level overlap. If somebody takes a 300-level computer science class, they may not be likely to take a 300-level history class. By identifying these trends in the data, we can hopefully find other likely candidates for co-scheduling. Similarly, this will cut down on needing to enumerate every pairwise course conflicts and improve the performance of the algorithm.



\begin{table}[]
\centering
\begin{tabular}{llll}
Subject & Occurrences & Subject & Occurrences \\
CITY    & 1           & RELG    & 3           \\
SOCL    & 1           & ARTS    & 3           \\
SPAN    & 1           & ANTH    & 3           \\
ICPR    & 1           & MUSC    & 5           \\
HIST    & 1           & POLS    & 9           \\
PHIL    & 1           & PSYC    & 11          \\
LING    & 2           &         &             \\        
\end{tabular}
\caption{Occurrences per subject of concurrent enrollment in a 100- and 300-level course in one subject}
\label{my-label}
\end{table}

\subsection{Additional Constraints}

\begin{enumerate}
\item{\textbf{Weighted preferences}}

When students select which classes they are going to take, they may have an idea of which ones are more important for them to get into. An obvious example of this could be courses for their major, minor, etc. Assuming a student has sorted preferences of $n$ classes (in descending order), computing initial costs between classes can be achieved according to the following formula:\\

$cost(c_i,c_j) = (n-i)+(n-j)$ \\

This way, courses which appear earlier in the list (higher preference) effectively conflict more than courses which appear later in the list (lower preference). Our algorithm takes this convention into account when it sets costs. In the case of the Haverford data, we have extended the constraints with student major and minor preferences. When preferences are read off of the student preferences file, they are sorted such that courses in a student's major appear before courses in a student's minor, which appear before all other courses. Total preference value must also be weighted such that a student beging enrolled in their top choice contributes more to the total preference value than a student being enrolled in their bottom choice. Evaluating preference value under this constraint can be achieved by using the {\it is\_valid\_weighted.pl} script. 

***** NOTE THESE CHANGES HAVE NOT BEEN MADE YET TO THE CODE *******

\item{Labs / connected courses}

\item{Courses taking more than one time slot}

\item{}

\item{}

\end{enumerate}


\end{document}